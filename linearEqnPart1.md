# Jacobi Iteration Method

The `jacobiMethod` function iteratively solves a system of linear equations (AX = B) using the Jacobi method, where an initial guess for (X) is updated until convergence or a maximum number of iterations is reached. For each variable (X[i]), the function computes a new value based on the latest values of the other variables, isolated in each equation and adjusted by the known constants (B[i]). After each update, it checks if the difference between the current and previous values is within a specified tolerance, indicating convergence. If convergence is achieved, the iteration stops early; otherwise, it runs up to the maximum iterations, reporting if it fails to converge within this limit. The `runjacobiiteration` function collects user input for the matrix (A), vector (B), initial parameters, and then calls `jacobiMethod` to solve and display the solution.
# Gauss-Seidel Method

The `gaussSeidelMethod` function solves a system of linear equations (AX = B) using the Gauss-Seidel iterative method, where each variable (X[i]) is updated in place as soon as a new value is computed, allowing the current iterationâ€™s values to be immediately reused in the same iteration. For each (X[i]), it calculates a new value by isolating (X[i]) in its equation and adjusting based on the other variables, then checks if the change from the previous value is within a specified `tolerance`. If all values converge within this tolerance, the iteration stops early; otherwise, it continues up to `maxIterations`, reporting if convergence is not reached within this limit. The `rungausseidel` function gathers input for the matrix (A), vector (B), iteration parameters, and calls `gaussSeidelMethod` to solve and display the result.
# LU Factorization Method

The `LU_factorization` function in the code performs LU decomposition with partial pivoting to solve a system of linear equations (AX = B). It factorizes matrix (A) into a lower triangular matrix (L) and an upper triangular matrix (U), enabling the solution of (AX = B) in two steps: (L . y = B) (solved using forward substitution) and (U . x = y) (solved using backward substitution). The code includes partial pivoting to enhance numerical stability, swapping rows in (U) (and adjusting (L) and (B) accordingly) whenever a large pivot element is found in a lower row. After decomposition, it displays the matrices (L) and (U) and uses forward and backward substitution to find and print the solution vector (X).
